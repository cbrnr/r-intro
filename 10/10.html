<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Clemens Brunner">

<title>10 – Lineare Regression (1) – Statistische Datenanalyse mit R</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-8b4baf804e461d9b72633f0de59a0cac.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-f1aadacce99040138bbb613f9330654f.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-8b4baf804e461d9b72633f0de59a0cac.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-70acd5334efd903f5a7ee98cc20b8936.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark-f43fd6ecb9380c5f2fb0abebe514624c.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../site_libs/bootstrap/bootstrap-70acd5334efd903f5a7ee98cc20b8936.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/quarto-contrib/academicons-1.9.2/all.css" rel="stylesheet">
<link href="../site_libs/quarto-contrib/academicons-1.9.2/size.css" rel="stylesheet">
<link href="../site_libs/quarto-contrib/fontawesome6-0.1.0/all.css" rel="stylesheet">
<link href="../site_libs/quarto-contrib/fontawesome6-0.1.0/latex-fontsize.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Keine Treffer",
    "search-matching-documents-text": "Treffer",
    "search-copy-link-title": "Link in die Suche kopieren",
    "search-hide-matches-text": "Zusätzliche Treffer verbergen",
    "search-more-match-text": "weitere Treffer in diesem Dokument",
    "search-more-matches-text": "weitere Treffer in diesem Dokument",
    "search-clear-button-title": "Zurücksetzen",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Abbrechen",
    "search-submit-button-title": "Abschicken",
    "search-label": "Suchen"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Statistische Datenanalyse mit R</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Suchen"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Navigation umschalten" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../01/01.html"> 
<span class="menu-text">1</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../02/02.html"> 
<span class="menu-text">2</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../03/03.html"> 
<span class="menu-text">3</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../04/04.html"> 
<span class="menu-text">4</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../05/05.html"> 
<span class="menu-text">5</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../06/06.html"> 
<span class="menu-text">6</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../07/07.html"> 
<span class="menu-text">7</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../08/08.html"> 
<span class="menu-text">8</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../09/09.html"> 
<span class="menu-text">9</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../10/10.html" aria-current="page"> 
<span class="menu-text">10</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../11/11.html"> 
<span class="menu-text">11</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../12/12.html"> 
<span class="menu-text">12</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://orcid.org/0000-0002-6030-2233"> 
<span class="menu-text"><i class="ai  ai-orcid" title="" style="color:"></i></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://scholar.social/web/@cbrnr"> 
<span class="menu-text"><i class="fa-brands fa-mastodon" aria-label="mastodon"></i></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/cbrnr"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="mailto:clemens.brunner@gmail.com"> <i class="bi bi-envelope-fill" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Dunkelmodus umschalten"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-page">
      <h1 class="title">10 – Lineare Regression (1)</h1>
            <p class="subtitle lead">Statistische Datenanalyse mit R</p>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta column-page">

      <div>
      <div class="quarto-title-meta-heading">Autor</div>
      <div class="quarto-title-meta-contents">
               <p>Clemens Brunner </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Veröffentlicht</div>
      <div class="quarto-title-meta-contents">
        <p class="date">8. Januar 2026</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block column-page" id="quarto-document-content">






<section id="einfache-lineare-regression" class="level2">
<h2 class="anchored" data-anchor-id="einfache-lineare-regression">Einfache lineare Regression</h2>
<p>Wir haben gesehen, dass man über die Korrelation die Beziehung zwischen zwei Variablen beschreiben kann. Man kann nun einen Schritt weiter gehen und versuchen, eine Variable durch die andere “vorherzusagen”. Eine weit verbreitete Methode dafür ist die lineare Regression, welche eine abhängige Variable durch <em>eine</em> unabhängige Variable (einfache Regression) bzw. durch <em>mehrere</em> unabhängige Variablen (multiple Regression) zu erklären versucht.</p>
<p>Ein allgemeines statistisches Modell kann man generell wie folgt aufstellen:</p>
<p><span class="math display">\[\mathrm{outcome}_i = \mathrm{model}_i + \mathrm{error}_i\]</span></p>
<p>Man beschreibt also die gemessenen Daten durch ein Modell, welches im Allgemeinen aber immer Fehler machen wird (d.h. es beschreibt die gemessenen Daten nicht perfekt). Um diese Formel kürzer anschreiben zu können, setzt man <span class="math inline">\(\mathrm{outcome}_i = y_i\)</span>, <span class="math inline">\(\mathrm{model}_i = \hat{y}_i\)</span> und <span class="math inline">\(\mathrm{error}_i = \varepsilon_i\)</span>:</p>
<p><span class="math display">\[y_i = \hat{y}_i + \varepsilon_i\]</span></p>
<p>Im Fall der linearen Regression ist das Modell <span class="math inline">\(\hat{y}_i\)</span> linear, also eine Gerade. Die Gleichung kann daher wie folgt angeschrieben werden:</p>
<p><span class="math display">\[y_i = \underbrace{\left(b_0 + b_1 x_i\right)}_{\hat{y}_i} + \varepsilon_i\]</span></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Hinweis
</div>
</div>
<div class="callout-body-container callout-body">
<p>Eine Geradengleichung kann in der Form <span class="math inline">\(y = k \cdot x + d\)</span> angeschrieben werden. Die zwei Parameter <span class="math inline">\(k\)</span> und <span class="math inline">\(d\)</span> sind wie folgt definiert:</p>
<ul>
<li><p>Der Schnittpunkt mit der y-Achse <span class="math inline">\(d\)</span> entspricht dem Wert von <span class="math inline">\(y\)</span> an der Stelle <span class="math inline">\(x=0\)</span>.</p></li>
<li><p>Die Steigung <span class="math inline">\(k\)</span> ist das Verhältnis der Änderung von <span class="math inline">\(y\)</span> (wird als <span class="math inline">\(\Delta y\)</span> geschrieben) zur Änderung von <span class="math inline">\(x\)</span> (wird als <span class="math inline">\(\Delta x\)</span> geschrieben):</p>
<p><span class="math display">\[k = \frac{\Delta y}{\Delta x}\]</span></p></li>
</ul>
</div>
</div>
<p>Die Parameter <span class="math inline">\(b_0\)</span> und <span class="math inline">\(b_1\)</span> beschreiben daher den Schnittpunkt der Geraden mit der y-Achse (Intercept) bzw. die Steigung der Geraden und werden als <em>Regressionskoeffizienten</em> bezeichnet. Der Term <span class="math inline">\(\varepsilon_i\)</span> beschreibt den Fehler zwischen den vom Modell vorhergesagten Wert <span class="math inline">\(\hat{y}_i\)</span> und dem tatsächlich gemessenen Wert <span class="math inline">\(y_i\)</span>.</p>
<p>Das tiefgestellte <span class="math inline">\(i\)</span> steht für den <span class="math inline">\(i\)</span>-ten Datenpunkt (von insgesamt <span class="math inline">\(N\)</span>). Das Modell gilt also für alle Datenpunkte <span class="math inline">\(i = 1, 2, \ldots, N\)</span>.</p>
<p>Die Datenpunkte <span class="math inline">\(x_i\)</span> können als Vektor <span class="math inline">\(\mathbf{x}\)</span> betrachtet werden; dieser wird als unabhängige Variable, Prädiktor oder Treatment bezeichnet. Die Datenpunkte <span class="math inline">\(y_i\)</span> können ebenfalls als Vektor <span class="math inline">\(\mathbf{y}\)</span> betrachtet werden; dieser wird als abhängige Variable oder Outcome bezeichnet. Die Fehler <span class="math inline">\(\varepsilon_i\)</span> werden als Residuen bezeichnet.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tipp
</div>
</div>
<div class="callout-body-container callout-body">
<p>Zur Veranschaulichung sind in der folgenden Abbildung drei Geraden mit gleichen Intercepts aber unterschiedlichen Steigungen (links) sowie unterschiedlichen Intercepts aber gleichen Steigungen (rechts) abgebildet.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="10_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid figure-img" width="960"></p>
</figure>
</div>
</div>
</div>
<p>In der linken Abbildung haben alle drei Geraden denselben Intercept <span class="math inline">\(b_0 = 50\)</span> (sie schneiden die y-Achse an der Stelle <span class="math inline">\(y = 50\)</span>). Die Steigung der ersten Geraden beträgt <span class="math inline">\(b_1 = 1\)</span>. Dies ist aus der Grafik ersichtlich, denn wenn man <span class="math inline">\(x\)</span> beispielsweise um 25 erhöht, dann erhöht sich <span class="math inline">\(y\)</span> ebenfalls um 25. Die Steigung beträgt also <span class="math inline">\(b_1 = \frac{\Delta y}{\Delta x} = \frac{25}{25} = 1\)</span>. Die Steigung der zweiten Geraden beträgt <span class="math inline">\(b_1 = -\frac{1}{3}\)</span>, denn wenn man <span class="math inline">\(x\)</span> um 75 erhöht, dann <em>erniedrigt</em> sich <span class="math inline">\(y\)</span> um 25. Die Steigung beträgt also <span class="math inline">\(b_1 = \frac{-25}{75} = -\frac{1}{3}\)</span>. Die Steigung der dritten Geraden ist entsprechend <span class="math inline">\(b_1 = \frac{-50}{75} = -\frac{2}{3}\)</span>.</p>
<p>In der rechten Abbildung haben alle drei Geraden die Steigung <span class="math inline">\(b_1 = \frac{25}{50} = \frac{1}{2}\)</span>. Die erste Gerade schneidet die y-Achse bei <span class="math inline">\(y = 70\)</span>, die zweite bei <span class="math inline">\(y = 50\)</span> und die dritte bei <span class="math inline">\(y = 20\)</span>, was den drei Intercepts entspricht.</p>
</div>
</div>
<p>Die Frage ist also nun, welche konkrete Gerade (also welches konkrete lineare Regressionsmodell) verwendet werden soll. Das Modell soll die Datenpunkte möglichst gut beschreiben, was meist durch die <a href="https://de.wikipedia.org/wiki/Methode_der_kleinsten_Quadrate">Methode der kleinsten Fehlerquadrate (Least Squares)</a> erreicht wird. Diese Methode findet jene Gerade, welche die quadrierten Unterschiede zwischen den vom Modell (der Geraden) vorhergesagten Werten <span class="math inline">\(\hat{y}_i\)</span> und den tatsächlich gemessenen Datenpunkten <span class="math inline">\(y_i\)</span> minimiert. Die Unterschiede (Fehler) werden hier als <em>Residuen</em> bezeichnet.</p>
<p>In der folgenden Grafik sind die Daten als schwarze Punkte, das Modell als schwarze Gerade und die Residuen als rote vertikale Linien dargestellt. Beachten Sie, dass es sowohl positive als auch negative Residuen gibt (in der Grafik sind beispielhaft zwei Werte zu sehen). Damit sich die positiven und negativen Terme nicht aufheben, werden die einzelnen Residuen zuerst quadriert und erst dann summiert – und diese Quadratsumme wird minimiert. Es wird also jene Gerade gesucht, welche die kleinste Quadratsumme ergibt. Die von dieser Methode gefundene Gerade hat also die kleinste Fehlerquadratsumme unter allen möglichen Geraden.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="10_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Hinweis
</div>
</div>
<div class="callout-body-container callout-body">
<p>Wir werden nicht darauf eingehen, wie die Methode der kleinsten Fehlerquadrate im Detail funktioniert. Es ist ausreichend zu wissen, dass diese Methode die optimale Gerade findet, also die Regressionskoeffizienten <span class="math inline">\(b_0\)</span> und <span class="math inline">\(b_1\)</span> so bestimmt, dass die Fehlerquadratsumme minimiert wird.</p>
</div>
</div>
</section>
<section id="quadratsummen" class="level2">
<h2 class="anchored" data-anchor-id="quadratsummen">Quadratsummen</h2>
<p>Die Fehlerquadratsumme ist ein (relatives) Maß für die Modellgüte (Model Fit). Für die gefundene Gerade ist diese Fehlerquadratsumme zwar immer minimal (unter allen möglichen Geraden), es ist aber trotzdem nicht klar, wie gut sich die Daten überhaupt mit einer Geraden beschreiben lassen. Deswegen vergleicht man das gefundene lineare Modell mit dem einfachsten linearen Modell, welches die Prädiktorvariable vollkommen ignoriert – dem Mittelwert über alle Datenpunkte <span class="math inline">\(y_i\)</span> (das entspricht einer waagrechten Geraden). Bei diesem Modell ist der Wert der Prädiktorvariable <span class="math inline">\(x_i\)</span> also vollkommen egal, da komplett unabhängig davon immer derselbe Wert für die abhängige Variable <span class="math inline">\(y_i\)</span> vorhergesagt wird. Das gefundene lineare Modell ist dann ein guter Fit, wenn es signifikant besser als dieses einfachste Modell ist.</p>
<p>Die Summe der quadratischen Abweichungen vom einfachsten Modell (Mittelwert) wird auch als SST bezeichnet (totale Quadratsumme). Die Summe der quadratischen Abweichungen vom linearen Modell wird als SSR (Residuenquadratsumme) bezeichnet. Schließlich gibt es noch die quadratischen Abweichungen des linearen Modells vom einfachsten Modell, welche man als SSM (Modellquadratsumme) bezeichnet.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="10_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid figure-img" width="1440"></p>
</figure>
</div>
</div>
</div>
<p>Die vorangegangenen drei Abbildungen veranschaulichen diese Quadratsummen. SST ist hier nichts anderes als die (nicht normierte) <em>Varianz</em> der Daten. SSM sollte möglichst groß sein, denn dann ist das lineare Modell wesentlich besser als die horizontale Gerade. SSR sollte möglichst klein sein bei einem guten Modell – an SSR sieht man die übrig gebliebene Varianz, die das Modell nicht erklären kann.</p>
<p>In mathematischer Notation kann man die Quadratsummen wie folgt anschreiben:</p>
<p><span class="math display">\[\mathrm{SST} = \sum_{i=1}^N (y_i - \bar{y})^2\]</span></p>
<p><span class="math display">\[\mathrm{SSR} = \sum_{i=1}^N (y_i - \hat{y}_i)^2\]</span></p>
<p><span class="math display">\[\mathrm{SSM} = \sum_{i=1}^N (\hat{y}_i - \bar{y})^2\]</span></p>
<p>Hier sind <span class="math inline">\(y_i\)</span> die einzelnen Messwerte, <span class="math inline">\(\bar{y}\)</span> ist der arithmetische Mittelwert und <span class="math inline">\(\hat{y}_i\)</span> sind die einzelnen vom Modell vorhergesagten Werte (also die auf der Geraden liegenden Werte). <span class="math inline">\(N\)</span> ist die Anzahl der Datenpunkte. In Formeln kann man <span class="math inline">\(\bar{y}\)</span> und <span class="math inline">\(\hat{y}_i\)</span> so schreiben:</p>
<p><span class="math display">\[\bar{y} = \frac{1}{N} \sum_{i=1}^N y_i\]</span></p>
<p><span class="math display">\[\hat{y}_i = b_0 + b_1 x_i\]</span></p>
<p>Es gilt:</p>
<p><span class="math display">\[\mathrm{SST} = \mathrm{SSM} + \mathrm{SSR}\]</span></p>
<p>Die totale Quadratsumme wird also in die vom Modell erklärte Quadratsumme und die nicht erklärte Quadratsumme zerlegt.</p>
</section>
<section id="modellgüte" class="level2">
<h2 class="anchored" data-anchor-id="modellgüte">Modellgüte</h2>
<section id="bestimmtheitsmaß-r2" class="level3">
<h3 class="anchored" data-anchor-id="bestimmtheitsmaß-r2">Bestimmtheitsmaß <span class="math inline">\(R^2\)</span></h3>
<p>Ein Maß für die Modellgüte ist das Verhältnis von SSM zu SST, welches als Bestimmtheitsmaß <span class="math inline">\(R^2\)</span> bezeichnet wird. Es ist der Anteil an Varianz der Daten, die vom Modell erklärt werden kann:</p>
<p><span class="math display">\[R^2 = \frac{\mathrm{SSM}}{\mathrm{SST}}\]</span></p>
<p>Dies ist derselbe Wert, den wir auch schon bei der Korrelation kennengelernt haben. Um die Pearson-Korrelation zwischen den beiden Variablen zu bekommen, muss man also nur die Wurzel aus <span class="math inline">\(R^2\)</span> ziehen. Diese Beziehung gilt in dieser Form allerdings nur für die einfache lineare Regression, also nur bei einer einzigen unabhängigen Variable.</p>
</section>
<section id="f-wert" class="level3">
<h3 class="anchored" data-anchor-id="f-wert"><span class="math inline">\(F\)</span>-Wert</h3>
<p>Eine weitere wichtige Anwendung der Quadratsummen ist die Berechnung des <span class="math inline">\(F\)</span>-Wertes. Dieser entspricht dem Verhältnis der systematischen Varianz (also der vom Modell erklärten Varianz) zur unsystematischen Varianz (also der Varianz, die nicht vom Modell erklärt werden kann). Für den <span class="math inline">\(F\)</span>-Wert verwendet man aber nicht direkt SSM und SSR, sondern die <em>mittleren</em> Quadratsummen. Hier dividiert man die absoluten Quadratsummen durch die jeweiligen Freiheitsgrade und erhält so MSM und MSR. Die Anzahl der Freiheitsgrade von MSM entspricht der Anzahl der geschätzten Modellparameter <span class="math inline">\(p\)</span> minus 1. Die Anzahl der Freiheitsgrade von MSR entspricht der Anzahl der Messwerte <span class="math inline">\(N\)</span> minus der Anzahl der geschätzten Modellparameter <span class="math inline">\(p\)</span>.</p>
<p><span class="math display">\[\mathrm{MSM} = \frac{\mathrm{SSM}}{\mathrm{dfM}} = \frac{\mathrm{SSM}}{p - 1}\]</span></p>
<p><span class="math display">\[\mathrm{MSR} = \frac{\mathrm{SSR}}{\mathrm{dfR}} = \frac{\mathrm{SSR}}{N - p}\]</span></p>
<p>Für die einfache Regression gibt es genau zwei Modellparameter <span class="math inline">\(b_0\)</span> und <span class="math inline">\(b_1\)</span>, daher ist <span class="math inline">\(p = 2\)</span>. Für die Freiheitsgrade der Modellquadratsumme gilt daher:</p>
<p><span class="math display">\[\mathrm{dfM} = p - 1 = 2 - 1 = 1\]</span></p>
<p>Die Freiheitsgrade der Residuenquadratsumme sind in diesem Fall dann</p>
<p><span class="math display">\[\mathrm{dfR} = N - p = N - 2.\]</span></p>
<p>Der <span class="math inline">\(F\)</span>-Wert kann dann wie folgt berechnet werden: <span class="math display">\[F=\frac{\mathrm{MSM}}{\mathrm{MSR}}\]</span></p>
<p>Dieser Wert ist ebenso wie <span class="math inline">\(R^2\)</span> ein Maß für die Güte des Modells. Er gibt an, wie viel Varianz das Modell erklärt gegenüber wie viel Varianz das Modell nicht erklärt. D.h. ein Wert von 1 entspricht dem Fall, dass die erklärte Varianz gleich groß ist wie die nicht erklärte – also ein schlechtes Modell. Für ein gutes Modell sollte daher <span class="math inline">\(F \gg 1\)</span> gelten.</p>
</section>
</section>
<section id="koeffizienten" class="level2">
<h2 class="anchored" data-anchor-id="koeffizienten">Koeffizienten</h2>
<p>In der einfachen linearen Regression entspricht der Regressionskoeffizient <span class="math inline">\(b_1\)</span> der Steigung der Geraden. Er entspricht der Änderung der abhängigen Variable (AV) auf der y-Achse relativ zu einer Änderung der unabhängigen Variable (UV) auf der x-Achse. Ein schlechtes Modell (wie das einfachste horizontale Modell) sagt immer denselben Wert für die AV vorher, unabhängig vom Wert der UV. Die Steigung <span class="math inline">\(b_1\)</span> ist für so ein Modell also Null. Wenn aber die UV den Wert der AV vorhersagen kann, muss die Steigung signifikant von Null verschieden sein. Diese Hypothese kann man mit dem sogenannten <span class="math inline">\(t\)</span>-Test überprüfen. Ein <span class="math inline">\(t\)</span>-Test kann also in der linearen Regression eingesetzt werden, um zu beurteilen, ob eine UV ein signifikanter Prädiktor für die AV ist.</p>
<p>Die <span class="math inline">\(t\)</span>-Statistik vergleicht das Modell mit seinem Fehler; konkret möchte man hier wissen, ob der beobachtete Wert des Regressionskoeffizienten groß gegenüber seinem Standardfehler ist:</p>
<p><span class="math display">\[t = \frac{b}{\mathrm{SE}_b}\]</span></p>
<p>Die Freiheitsgrade dieser <em>t</em>-Statistik sind <span class="math inline">\(N-p\)</span>, also im Fall der einfachen linearen Regression <span class="math inline">\(N-2\)</span>.</p>
</section>
<section id="beispiel" class="level2">
<h2 class="anchored" data-anchor-id="beispiel">Beispiel</h2>
<p>Wie man eine Regressionsanalyse in R durchführt lässt sich am besten anhand eines Beispiels zeigen. Importieren wir dazu einen Datensatz <a href="sales1.dat"><code>sales1.dat</code></a>, welcher Daten über Musikalbenverkäufe (Spalte <code>sales</code>) und die Höhe des Werbebudgets (Spalte <code>adverts</code>) enthält:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(readr)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>(<span class="at">album =</span> <span class="fu">read_tsv</span>(<span class="st">"sales1.dat"</span>))</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 200 × 2
   adverts sales
     &lt;dbl&gt; &lt;dbl&gt;
 1    10.3   330
 2   986.    120
 3  1446.    360
 4  1188.    270
 5   575.    220
 6   569.    170
 7   472.     70
 8   537.    210
 9   514.    200
10   174.    300
# ℹ 190 more rows</code></pre>
</div>
</div>
<p>Es ist anzunehmen, dass ein höheres Werbebudget zu höheren Verkaufszahlen führt. Neben der Berechnung diverser deskriptiver Statistiken (wird hier nicht durchgeführt) ist es sinnvoll, die Daten vor einer Regressionsanalyse grafisch darzustellen. Hier bietet sich ein Scatterplot mit überlagerter Regressionsgeraden an (das Argument von <code>abline()</code>, nämlich <code>lm(sales ~ adverts, data=album)</code>, ist das Regressionsmodell und wird gleich erklärt):</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">x=</span>album<span class="sc">$</span>adverts,</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">y=</span>album<span class="sc">$</span>sales,</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">pch=</span><span class="dv">21</span>,</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">bg=</span><span class="fu">rgb</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="fl">0.5</span>),</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">xlab=</span><span class="st">"Adverts (1000 EUR)"</span>,</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">ylab=</span><span class="st">"Sales (1000)"</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="fu">lm</span>(sales <span class="sc">~</span> adverts, <span class="at">data=</span>album), <span class="at">col=</span><span class="st">"blue"</span>, <span class="at">lwd=</span><span class="dv">2</span>)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="10_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Es ist klar, dass eine positive Beziehung zwischen den beiden Variablen besteht (je größer das Werbebudget desto mehr Albenverkäufe). Außerdem ist die Steigung der Regressionsgeraden stark verschieden von Null, d.h. es ist zu erwarten, dass das Regressionsmodell signifikant ist.</p>
<p>In R kann man mit der Funktion <code>lm()</code> (steht für “linear model”) eine Regressionsanalyse durchführen:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>model <span class="ot">=</span> <span class="fu">lm</span>(sales <span class="sc">~</span> adverts, <span class="at">data=</span>album)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Das erste Argument <code>sales ~ adverts</code> ist eine Formel (welche durch eine Tilde <code>~</code> gekennzeichnet ist). Diese Formel kann man als “<code>sales</code> wird vorhergesagt durch <code>adverts</code>” lesen. Im Allgemeinen nimmt die Formel die Form <code>AV ~ UV</code> an. Mit dem Argument <code>data=album</code> teilt man der Funktion mit, dass sich die Namen in der Formel auf Spaltennamen des Data Frames <code>album</code> beziehen.</p>
<p>Das Ergebnis der Regressionsanalyse weisen wir hier der Variablen <code>model</code> zu. Eine kompakte Darstellung des Ergebnisses kann man sich ausgeben lassen, indem man sich eine Zusammenfassung des Modells mittels <code>summary()</code> ansieht:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(model)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = sales ~ adverts, data = album)

Residuals:
     Min       1Q   Median       3Q      Max 
-152.949  -43.796   -0.393   37.040  211.866 

Coefficients:
             Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept) 1.341e+02  7.537e+00  17.799   &lt;2e-16 ***
adverts     9.612e-02  9.632e-03   9.979   &lt;2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 65.99 on 198 degrees of freedom
Multiple R-squared:  0.3346,    Adjusted R-squared:  0.3313 
F-statistic: 99.59 on 1 and 198 DF,  p-value: &lt; 2.2e-16</code></pre>
</div>
</div>
<p>Beginnen wir mit der vorletzten Zeile:</p>
<pre><code>Multiple R-squared:  0.3346,    Adjusted R-squared:  0.3313</code></pre>
<p>Hier sehen wir <span class="math inline">\(R^2\)</span>, also das Verhältnis von SSM zu SST. Daraus können wir schließen, dass die Werbeausgaben ca. 33.5% der Varianz der Albenverkäufe erklären können. Dies bedeutet natürlich, dass ca. 66.5% der Varianz unerklärt ist, d.h. es muss andere relevante Faktoren dafür geben, die wir nicht im Modell berücksichtigt haben.</p>
<p>Im Fall der einfachen linearen Regression können wir auch sofort die Pearson-Korrelation zwischen den beiden Variablen berechnen, indem wir die Wurzel aus <span class="math inline">\(R^2\)</span> ziehen:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sqrt</span>(<span class="fu">summary</span>(model)<span class="sc">$</span>r.squared)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.5784877</code></pre>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tipp
</div>
</div>
<div class="callout-body-container callout-body">
<p>Das Objekt <code>summary(model)</code> ist eine Liste, welche diverse Informationen über das Modell enthält. Man kann die einzelnen Elemente der Liste mit dem <code>$</code>-Operator (oder mit <code>[[ ]]</code>) extrahieren, genau wie bei einem Data Frame. Eine Übersicht über die Elemente der Liste erhält man mit <code>names(summary(model))</code>:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(<span class="fu">summary</span>(model))</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] "call"          "terms"         "residuals"     "coefficients"  "aliased"       "sigma"         "df"           
 [8] "r.squared"     "adj.r.squared" "fstatistic"    "cov.unscaled" </code></pre>
</div>
</div>
</div>
</div>
<p>Diesen Wert könnte man jetzt vergleichen mit jenem aus der direkten Berechnung der Korrelation (z.B. mit <code>cor()</code> oder <code>cor.test()</code>) – das Ergebnis ist identisch:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cor</span>(album<span class="sc">$</span>adverts, album<span class="sc">$</span>sales)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.5784877</code></pre>
</div>
</div>
<p>Die letzte Zeile der Modellzusammenfassung zeigt die <span class="math inline">\(F\)</span>-Statistik und deren Signifikanz:</p>
<pre><code>F-statistic: 99.59 on 1 and 198 DF,  p-value: &lt; 2.2e-16</code></pre>
<p>Die <span class="math inline">\(F\)</span>-Statistik ist das Verhältnis von MSM zu MSR. Der Wert liegt bei 99.59, was bei Freiheitsgraden 1 und 198 einer Signifikanz von <span class="math inline">\(p&lt;0.001\)</span> entspricht. Dies bedeutet, dass die Wahrscheinlichkeit kleiner als 0.1% ist, diesen <span class="math inline">\(F\)</span>-Wert (oder einen noch größeren) unter der Nullhypothese (das Modell unterscheidet sich nicht vom einfachen Mittelwertsmodell) zu erhalten. Wir können also daraus schließen, dass das lineare Modell signifikant besser als das einfachste Modell ist.</p>
<p>Der <span class="math inline">\(F\)</span>-Wert bedeutet also, dass das Modell insgesamt ein guter Fit der Daten ist (verglichen mit dem globalen Mittelwert). Es wird aber eigentlich keine Aussage über die individuellen Prädiktoren getroffen (wobei man im Fall der einfachen Regression natürlich darauf schließen kann, dass die Steigung <span class="math inline">\(b_1\)</span> dann ebenfalls ein guter Prädiktor ist). In der Zusammenfassung sind die beiden Regressionskoeffizienten wie folgt dargestellt:</p>
<pre><code>Coefficients:
             Estimate Std. Error t value Pr(&gt;|t|)
(Intercept) 1.341e+02  7.537e+00  17.799   &lt;2e-16 ***
adverts     9.612e-02  9.632e-03   9.979   &lt;2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1</code></pre>
<p>In der Zeile <code>(Intercept)</code> enthält die Spalte <code>Estimate</code> den Wert für <span class="math inline">\(b_0\)</span>, also die Albenverkäufe wenn das Werbebudget gleich 0 ist (Schnittpunkt mit der y-Achse). Dieser Wert beträgt <code>1.341e+02</code>, also 134.1, was 134100 Verkäufen entspricht (weil die Einheit der <code>sales</code>-Variable 1000 Verkäufe ist).</p>
<p>Der Wert für <span class="math inline">\(b_1\)</span>, also die Steigung der Geraden, ist in der Zeile <code>adverts</code> mit <code>9.612e-02</code>, also 0.09612 abzulesen. Das bedeutet, wenn die Prädiktorvariable <code>adverts</code> sich um eine Einheit ändert, dann ändert sich die Ergebnisvariable <code>sales</code> um 0.09612 Einheiten. Wenn man das Werbebudget also um 1000€ erhöht, verkauft man 96 Alben mehr.</p>
<p>Weiters sieht man die Standardfehler der Koeffizienten sowie deren <span class="math inline">\(t\)</span>-Werte. Die letzte Spalte <code>Pr(&gt;|t|)</code> gibt die <span class="math inline">\(p\)</span>-Werte an inklusive Codes für signifikante Ergebnisse. Beide Koeffizienten sind signifikant mit <span class="math inline">\(p&lt;0.001\)</span>, wobei uns hier eigentlich nur die Steigung der Geraden interessiert und es für uns nicht wichtig ist, ob der Intercept signifikant von Null verschieden ist.</p>
</section>
<section id="werte-vorhersagen" class="level2">
<h2 class="anchored" data-anchor-id="werte-vorhersagen">Werte vorhersagen</h2>
<p>Das Objekt <code>model</code> kann man nun verwenden, um neue Werte für <code>sales</code> in Abhängigkeit von <code>adverts</code> vorherzusagen. Hierfür muss man einfach die berechneten Werte von <span class="math inline">\(b_0\)</span> und <span class="math inline">\(b_1\)</span> in das lineare Modell einsetzen. Die exakten Koeffizienten erhält man mit <code>model$coefficients</code> oder <code>coefficients(model)</code>.</p>
<p><span class="math display">\[\hat{y} = b_0 + b_1 x = 134.1 + 0.09612 \cdot x\]</span></p>
<p>Nun kann man berechnen, wie hoch die Verkäufe <span class="math inline">\(y\)</span> wären, wenn man ein Werbebudget von <span class="math inline">\(x=100\)</span> hätte:</p>
<p><span class="math display">\[\hat{y} = 134.1 + 0.09612 \cdot 100 = 143.75\]</span></p>
<p>D.h. bei einem Werbebudget von 100000 EUR würde man 143750 Alben verkaufen.</p>
<p>Einfacher und allgemeiner kann man aber die Funktion <code>predict()</code> verwenden. Als Argumente gibt man das Modell und die neuen Daten an (welche als Data Frame übergeben werden müssen):</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">predict</span>(model, <span class="fu">data.frame</span>(<span class="at">adverts=</span><span class="dv">100</span>))</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>       1 
143.7524 </code></pre>
</div>
</div>
<p>So kann man auch gleich Vorhersagen für mehrere Werte gleichzeitig berechnen:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">predict</span>(model, <span class="fu">data.frame</span>(<span class="at">adverts=</span><span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">100</span>, <span class="dv">2000</span>)))</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>       1        2        3        4 
134.1399 135.1012 143.7524 326.3889 </code></pre>
</div>
</div>
</section>
<section id="übungen" class="level2">
<h2 class="anchored" data-anchor-id="übungen">Übungen</h2>
<section id="übung-1" class="level3">
<h3 class="anchored" data-anchor-id="übung-1">Übung 1</h3>
<p>Die Datei <a href="cars.csv"><code>cars.csv</code></a> enthält mehrere Messwerte für den Bremsweg (<code>dist</code>) von Autos die bei einer bestimmten Geschwindigkeit (<code>speed</code>) bremsen. Wir wollen untersuchen, ob es einen (linearen) Zusammenhang zwischen der Geschwindigkeit und dem Bremsweg gibt. Stellen Sie zunächst beide Variablen in einem Scatterplot dar (<code>speed</code> auf der <em>x</em>-Achse und <code>dist</code> auf der <em>y</em>-Achse).</p>
</section>
<section id="übung-2" class="level3">
<h3 class="anchored" data-anchor-id="übung-2">Übung 2</h3>
<p>Führen Sie mit den Daten aus Übung 1 eine lineare Regressionsanalyse durch und stellen Sie die Ergebnisse zusammengefasst dar. Erwähnen Sie die wichtigsten Eckpunkte Ihres Regressionsmodells.</p>
</section>
<section id="übung-3" class="level3">
<h3 class="anchored" data-anchor-id="übung-3">Übung 3</h3>
<p>Berechnen Sie die Pearson-Korrelation zwischen den beiden Variablen (ohne Verwendung von <span class="math inline">\(R^2\)</span> aus dem Modell) und überprüfen Sie, ob dieser Wert mit <span class="math inline">\(R^2\)</span> aus dem Regressionsmodell übereinstimmt.</p>
</section>
<section id="übung-4" class="level3">
<h3 class="anchored" data-anchor-id="übung-4">Übung 4</h3>
<p>Wie lautet die Gleichung der Regressionsgeraden? Welche Bremswege sagt das Modell für Geschwindigkeiten von 5 bzw. 65 voraus? Verwenden Sie für die Vorhersage sowohl die Geradengleichung als auch die Funktion <code>predict()</code>.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Kopiert");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Kopiert");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/cbrnr\.github\.io\/r-intro\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>© Clemens Brunner</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>